import Foundation

extension Image {
    mutating func eraseSymtab() {
        updateMachs { $0.eraseSymtab() }
    }

    mutating func eraseSwiftReflectiveSections() {
        updateMachs { $0.eraseSwiftReflectiveSections() }
    }

    mutating func eraseMethTypeSection() {
        updateMachs { $0.eraseMethTypeSection() }
    }

    mutating func eraseSection(_ sectionName: String, segment segmentName: String) {
        updateMachs { $0.eraseSection(sectionName, segment: segmentName) }
    }

    // cstring contain filenames that are generated by #file (in Swift) or __FILE__ (C/C++/ObjC)
    // In particular they appear when using fatalError in Swift.
    // They are stored in binary near class names, so they are deleted to not give original class name this way.
    // TODO: more robust means of detecting paths could be used (regex?)
    mutating func eraseFilePaths(_ prefixes: [String], usingReplacement replacement: String) {
        updateMachs { $0.eraseFilePaths(prefixes, usingReplacement: replacement) }
    }
}

private extension Mach {
    mutating func eraseSymtab() {
        guard let symtabRange = symtab?.stringTableRange else {
            return
        }
        data.nullify(range: symtabRange.intRange)
    }

    mutating func eraseSwiftReflectiveSections() {
        for section in swiftReflectionSections {
            data.nullify(range: section.range.intRange)
        }
    }

    mutating func eraseMethTypeSection() {
        guard let methTypeSectionRange = objcMethTypeSection?.range else {
            return
        }

        data.nullify(range: methTypeSectionRange.intRange)
    }

    mutating func eraseSection(_ sectionName: String, segment segmentName: String) {
        guard let sect = section(sectionName, segment: segmentName) else {
            return
        }
        data.nullify(range: sect.range.intRange)
    }

    mutating func eraseFilePaths(_ prefixes: [String], usingReplacement replacement: String) {
        guard !prefixes.isEmpty else {
            // nothing to do
            return
        }

        data.replaceStrings(inRange: cstringSection!.range.intRange, withMapping: {
            LOGGER.debug("Removing filename \($0)")
            return replacement
        }, withFilter: {
            cstring in cstring.utf8.count >= replacement.utf8.count &&
                prefixes.reduce(false) { result, nextMask in result || cstring.starts(with: nextMask) }
        })
    }
}
